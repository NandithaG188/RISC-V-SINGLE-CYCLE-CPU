// EcoMender Bot : Task 1B : Color Detection using State Machines
/*
Instructions
-------------------
Students are not allowed to make any changes in the Module declaration.
This file is used to design a module which will detect colors red, green, and blue using state machine and frequency detection.

Recommended Quartus Version : 20.1
The submitted project file must be 20.1 compatible as the evaluation will be done on Quartus Prime Lite 20.1.

Warning: The error due to compatibility will not be entertained.
-------------------
*/

//Color Detection
//Inputs : clk_1MHz, cs_out
//Output : filter, color

// Module Declaration
module t1b_cd_fd (
    input  clk_1MHz, cs_out,
    output reg [1:0] filter, color
);

// red   -> color = 1;
// green -> color = 2;
// blue  -> color = 3;

//////////////////DO NOT MAKE ANY CHANGES ABOVE THIS LINE //////////////////

initial begin // editing this initial block is allowed
    filter = 2; 
    color = 0;
end

// State encoding for filter control
localparam [1:0] FILTER_CLEAR = 2'b11, // 3
                 FILTER_RED   = 2'b00, // 0
                 FILTER_BLUE  = 2'b01, // 1
                 FILTER_GREEN = 2'b10; // 2

// Timing constants
localparam integer FILTER_DURATION = 500; // 500 µs for each filter except last
localparam integer LAST_FILTER_DURATION = 1; // 1 µs for last filter

// Variables to store frequency counts for each color
reg [15:0] red_count, green_count, blue_count;
reg [1:0] current_state;
reg [9:0] timer; // 10-bit counter to count up to 500

// Frequency detection counter
reg [15:0] freq_counter;

// State machine for filter swapping with timing control
always @(posedge clk_1MHz) begin
    // Check if timer reached the required duration for each filter state
    if (timer >= (current_state == FILTER_GREEN ? LAST_FILTER_DURATION : FILTER_DURATION)) begin
        case (current_state)
            FILTER_CLEAR: begin
                filter <= FILTER_RED;
                red_count <= freq_counter;    // Store frequency count for red
                freq_counter <= 0;            // Reset frequency counter
                current_state <= FILTER_RED;  // Move to the next state
                timer <= 0;                   // Reset timer
            end
            FILTER_RED: begin
                filter <= FILTER_BLUE;
                blue_count <= freq_counter;   // Store frequency count for blue
                freq_counter <= 0;            // Reset frequency counter
                current_state <= FILTER_BLUE; // Move to the next state
                timer <= 0;                   // Reset timer
            end
            FILTER_BLUE: begin
                filter <= FILTER_GREEN;
                green_count <= freq_counter;  // Store frequency count for green
                freq_counter <= 0;            // Reset frequency counter
                current_state <= FILTER_GREEN;// Move to the last state
                timer <= 0;                   // Reset timer
            end
            FILTER_GREEN: begin
                filter <= FILTER_CLEAR;
                current_state <= FILTER_CLEAR;// Restart the sequence
                timer <= 0;                   // Reset timer
                
                // Logic to detect color based on frequency count
                if (red_count > green_count && red_count > blue_count)
                    color <= 1; // Red
                else if (green_count > red_count && green_count > blue_count)
                    color <= 2; // Green
                else if (blue_count > red_count && blue_count > green_count)
                    color <= 3; // Blue
                else
                    color <= 0; // No dominant color detected
            end
        endcase
    end else begin
        // Increment timer each clock cycle
        timer <= timer + 1;
        
        // Increment frequency counter if cs_out is high
        if (cs_out) freq_counter <= freq_counter + 1;
    end
end

//////////////////DO NOT MAKE ANY CHANGES BELOW THIS LINE //////////////////

endmodule
